#include "matrix.h"
#include <stdio.h>

mat4 multMat4Mat4(mat4 a, mat4 b){
  mat4 ret;
  ret.m[0][0] = a.m[0][0]*b.m[0][0]+a.m[0][1]*b.m[1][0]+a.m[0][2]*b.m[2][0]+a.m[0][3]*b.m[3][0];
  ret.m[0][1] = a.m[0][0]*b.m[0][1]+a.m[0][1]*b.m[1][1]+a.m[0][2]*b.m[2][1]+a.m[0][3]*b.m[3][1];
  ret.m[0][2] = a.m[0][0]*b.m[0][2]+a.m[0][1]*b.m[1][2]+a.m[0][2]*b.m[2][2]+a.m[0][3]*b.m[3][2];
  ret.m[0][3] = a.m[0][0]*b.m[0][3]+a.m[0][1]*b.m[1][3]+a.m[0][2]*b.m[2][3]+a.m[0][3]*b.m[3][3];


  ret.m[1][0] = a.m[1][0]*b.m[0][0]+a.m[1][1]*b.m[1][0]+a.m[1][2]*b.m[2][0]+a.m[1][3]*b.m[3][0];
  ret.m[1][1] = a.m[1][0]*b.m[0][1]+a.m[1][1]*b.m[1][1]+a.m[1][2]*b.m[2][1]+a.m[1][3]*b.m[3][1];
  ret.m[1][2] = a.m[1][0]*b.m[0][2]+a.m[1][1]*b.m[1][2]+a.m[1][2]*b.m[2][2]+a.m[1][3]*b.m[3][2];
  ret.m[1][3] = a.m[1][0]*b.m[0][3]+a.m[1][1]*b.m[1][3]+a.m[1][2]*b.m[2][3]+a.m[1][3]*b.m[3][3];


  ret.m[2][0] = a.m[2][0]*b.m[0][0]+a.m[2][1]*b.m[1][0]+a.m[2][2]*b.m[2][0]+a.m[2][3]*b.m[3][0];
  ret.m[2][1] = a.m[2][0]*b.m[0][1]+a.m[2][1]*b.m[1][1]+a.m[2][2]*b.m[2][1]+a.m[2][3]*b.m[3][1];
  ret.m[2][2] = a.m[2][0]*b.m[0][2]+a.m[2][1]*b.m[1][2]+a.m[2][2]*b.m[2][2]+a.m[2][3]*b.m[3][2];
  ret.m[2][3] = a.m[2][0]*b.m[0][3]+a.m[2][1]*b.m[1][3]+a.m[2][2]*b.m[2][3]+a.m[2][3]*b.m[3][3];

  ret.m[3][0] = a.m[3][0]*b.m[0][0]+a.m[3][1]*b.m[1][0]+a.m[3][2]*b.m[2][0]+a.m[3][3]*b.m[3][0];
  ret.m[3][1] = a.m[3][0]*b.m[0][1]+a.m[3][1]*b.m[1][1]+a.m[3][2]*b.m[2][1]+a.m[3][3]*b.m[3][1];
  ret.m[3][2] = a.m[3][0]*b.m[0][2]+a.m[3][1]*b.m[1][2]+a.m[3][2]*b.m[2][2]+a.m[3][3]*b.m[3][2];
  ret.m[3][3] = a.m[3][0]*b.m[0][3]+a.m[3][1]*b.m[1][3]+a.m[3][2]*b.m[2][3]+a.m[3][3]*b.m[3][3];
  return ret;
}
void multmat4mat4Ptr(mat4* out, mat4 *a, mat4 *b){
  out->m[0][0] = a->m[0][0]*b->m[0][0]+a->m[0][1]*b->m[1][0]+a->m[0][2]*b->m[2][0]+a->m[0][3]*b->m[3][0];
  out->m[0][1] = a->m[0][0]*b->m[0][1]+a->m[0][1]*b->m[1][1]+a->m[0][2]*b->m[2][1]+a->m[0][3]*b->m[3][1];
  out->m[0][2] = a->m[0][0]*b->m[0][2]+a->m[0][1]*b->m[1][2]+a->m[0][2]*b->m[2][2]+a->m[0][3]*b->m[3][2];
  out->m[0][3] = a->m[0][0]*b->m[0][3]+a->m[0][1]*b->m[1][3]+a->m[0][2]*b->m[2][3]+a->m[0][3]*b->m[3][3];
  out->m[1][0] = a->m[1][0]*b->m[0][0]+a->m[1][1]*b->m[1][0]+a->m[1][2]*b->m[2][0]+a->m[1][3]*b->m[3][0];
  out->m[1][1] = a->m[1][0]*b->m[0][1]+a->m[1][1]*b->m[1][1]+a->m[1][2]*b->m[2][1]+a->m[1][3]*b->m[3][1];
  out->m[1][2] = a->m[1][0]*b->m[0][2]+a->m[1][1]*b->m[1][2]+a->m[1][2]*b->m[2][2]+a->m[1][3]*b->m[3][2];
  out->m[1][3] = a->m[1][0]*b->m[0][3]+a->m[1][1]*b->m[1][3]+a->m[1][2]*b->m[2][3]+a->m[1][3]*b->m[3][3];
  out->m[2][0] = a->m[2][0]*b->m[0][0]+a->m[2][1]*b->m[1][0]+a->m[2][2]*b->m[2][0]+a->m[2][3]*b->m[3][0];
  out->m[2][1] = a->m[2][0]*b->m[0][1]+a->m[2][1]*b->m[1][1]+a->m[2][2]*b->m[2][1]+a->m[2][3]*b->m[3][1];
  out->m[2][2] = a->m[2][0]*b->m[0][2]+a->m[2][1]*b->m[1][2]+a->m[2][2]*b->m[2][2]+a->m[2][3]*b->m[3][2];
  out->m[2][3] = a->m[2][0]*b->m[0][3]+a->m[2][1]*b->m[1][3]+a->m[2][2]*b->m[2][3]+a->m[2][3]*b->m[3][3];
  out->m[3][0] = a->m[3][0]*b->m[0][0]+a->m[3][1]*b->m[1][0]+a->m[3][2]*b->m[2][0]+a->m[3][3]*b->m[3][0];
  out->m[3][1] = a->m[3][0]*b->m[0][1]+a->m[3][1]*b->m[1][1]+a->m[3][2]*b->m[2][1]+a->m[3][3]*b->m[3][1];
  out->m[3][2] = a->m[3][0]*b->m[0][2]+a->m[3][1]*b->m[1][2]+a->m[3][2]*b->m[2][2]+a->m[3][3]*b->m[3][2];
  out->m[3][3] = a->m[3][0]*b->m[0][3]+a->m[3][1]*b->m[1][3]+a->m[3][2]*b->m[2][3]+a->m[3][3]*b->m[3][3];
}
// mat4 multMat4Mat4(mat4 a, mat4 b){
//   mat4 ret ={0};
//   for(int i=0; i<4; i++){
//     for(int j=0; j<4; j++){
//       for(int k=0; k<4; k++){
//         ret.m[i][j]+=a.m[i][k]*b.m[k][j];
//       }
//     }
//   }
//   return ret;
// }

vec3 multMat4Vec3(mat4 m, vec3 v){
  vec3 ret;
  ret.x = v.x * m.m  [0][0] + v.y * m.m[0][1] + v.z * m.m[0][2]+ m.m[0][3];
  ret.y = v.x * m.m  [1][0] + v.y * m.m[1][1] + v.z * m.m[1][2]+ m.m[1][3];
  ret.z = v.x * m.m  [2][0] + v.y * m.m[2][1] + v.z * m.m[2][2]+ m.m[2][3];
  float w = v.x * m.m[3][0] + v.y * m.m[3][1] + v.z * m.m[3][2]+ m.m[3][3];
  if(w == 0.0f || w == 1.0f){
    return ret;
  }
  w = 1.0f/w;
  ret.x*= w;
  ret.y*=w;
  ret.z*=w;
  return ret;
}

vec3 multMat4Vec3Normal(mat4 m, vec3 v){
  vec3 ret;
  ret.x = v.x * m.m  [0][0] + v.y * m.m[0][1] + v.z * m.m[0][2];
  ret.y = v.x * m.m  [1][0] + v.y * m.m[1][1] + v.z * m.m[1][2];
  ret.z = v.x * m.m  [2][0] + v.y * m.m[2][1] + v.z * m.m[2][2];
  return ret;
}

void multMat4Vec3Ptr(vec3* out, mat4* m, vec3 *v){
  out->x = v->x * m->m  [0][0] + v->y * m->m[0][1] + v->z * m->m[0][2]+ m->m[0][3];
  out->y = v->x * m->m  [1][0] + v->y * m->m[1][1] + v->z * m->m[1][2]+ m->m[1][3];
  out->z = v->x * m->m  [2][0] + v->y * m->m[2][1] + v->z * m->m[2][2]+ m->m[2][3];
  float w = v->x * m->m[3][0] + v->y * m->m[3][1] + v->z * m->m[3][2]+ m->m[3][3];
  if(w == 0.0f || w == 1.0f){
    return;
  }
  w = 1.0f/w;
  out->x*= w;
  out->y*=w;
  out->z*=w;
}
